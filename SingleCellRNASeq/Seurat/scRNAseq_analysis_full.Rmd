---
title: "Single Cell RNA-Seq Data Analysis with Human Data"
author: "Anni Liu"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: 
  html_document:
    code_folding: show
---

```{r}
library(Seurat)
library(ggplot2)
```

# Load the matrix.mtx, features.tsv, and barcodes.tsv files generated from 10x Genomics 
```{r}
sc_data <- Read10X(data.dir = "~/scRNA_analysis/data/filtered_gene_bc_matrices/hg19/")
```

# Create a Seurat object
```{r}
seurat_obj <- CreateSeuratObject(counts = sc_data, project = "scRNAseq", min.cells = 3, min.features = 200)
```

# Scale: load 10x Genomics data from multiple samples, create multiple Seurat objects, and merge all Seurat objects
```{r}
for (folder_name in c("wt_raw_feature_bc_matrix", "kd_raw_feature_bc_matrix", "over_raw_feature_bc_matrix")){
  sc_data <- Read10X(data.dir = paste0("~/scRNA_analysis/data/", folder_name))
  seurat_obj <- CreateSeuratObject(counts = sc_data, 
                                   min.features = 100, 
                                   project = folder_name)
  assign(folder_name, seurat_obj)
}

multi_seurat_obj <- merge(x = wt_raw_feature_bc_matrix, 
                          y = c(kd_raw_feature_bc_matrix, over_raw_feature_bc_matrix),
                          add.cell.id = c("wt", "kd", "over"))
```

# Add meta data
```{r}
meta_data <- multi_seurat_obj@meta.data
meta_data$cell_id <- rownames(meta_data)
meta_data$group <- gsub("^wt_.*", "wt",
  gsub("^kd_.*", "kd",
    gsub("^over_.*", "over", meta_data$cell_id)))
meta_data$batch_id <- gsub("wt", 1,
  gsub("kd", 2,
    gsub("over", 3, meta_data$group)))
multi_seurat_obj@meta.data <- meta_data
```

# Estimate and visualize QC metrics individually and jointly; filter out low-quality cells
```{r}
# QC a single sample
View(seurat_obj@meta.data) # nCount_RNA: number of UMIs per cell; nFeature_RNA: number of genes detected per cell
seurat_obj$log10_gene_per_UMI <- log10(seurat_obj$nFeature_RNA) / log10(seurat_obj$nCount_RNA)
seurat_obj$percent_mt <- PercentageFeatureSet(seurat_obj, pattern = "^MT-")
seurat_obj <- subset(x = seurat_obj, subset = nFeature_RNA >= 200 & nFeature_RNA >= 500 & log10_gene_per_UMI > 0.8 & percent_mt < 5)

# QC multiple samples
View(multi_seurat_obj@meta.data)
multi_seurat_obj$log10_gene_per_UMI <- log10(multi_seurat_obj$nFeature_RNA) / log10(multi_seurat_obj$nCount_RNA)
multi_seurat_obj$percent_mt <- PercentageFeatureSet(multi_seurat_obj, pattern = "^MT-")

## Cell counts per sample
multi_seurat_obj@meta.data |>
  ggplot(mapping = aes(x = group, fill = group)) + 
  geom_bar() +
  ggtitle("Number of unique cellular barcodes detected") + 
  theme_bw()

## UMI counts per cell
multi_seurat_obj@meta.data |>
  ggplot(mapping = aes(color = group, x = nCount_RNA, fill = group)) + 
  geom_density(alpha = 0.6) + 
  geom_vline(xintercept = 500)
  scale_x_log10() + 
  ylab("Density") +
  ggtitle("Number of transcripts per cell") + 
  theme_bw()

## Number of genes detected per cell
multi_seurat_obj@meta.data |>
  ggplot(mapping = aes(color = group, x = nFeature_RNA, fill = group)) + 
  geom_density(alpha = 0.6) + 
  geom_vline(xintercept = 200)
  scale_x_log10() + 
  ylab("Density") +
  ggtitle("Number of genes detected per cell") + 
  theme_bw()

## Number of genes detected per UMI in a cell
multi_seurat_obj@meta.data |>
  ggplot(mapping = aes(x = log10_gene_per_UMI, color = group, fill = group)) +
  geom_density(alpha = 0.6) +
  geom_vline(xintercept = 0.8) + 
  ggtitle("Number of genes detected per UMI in a cell") + 
  theme_bw()

## Mitochondrial percentage
multi_seurat_obj@meta.data |>
  ggplot(mapping = aes(color = group, x = percent_mt, fill = group)) + 
  geom_density(alpha = 0.6) + 
  geom_vline(xintercept = 5) + 
  scale_x_log10() + 
  ggtitle("Percentage of transcripts mapping to mitochondrial genes per cell") + 
  theme_bw()

## ! Joint visualization of UMI counts per cell, number of genes detected per cell, and mitochondrial percentage
multi_seurat_obj@meta.data |>
  ggplot(mapping = aes(x = nCount_RNA, y = nFeature_RNA, color = percent_mt)) + 
  geom_point() + 
  geom_vline(xintercept = 500) +
  geom_hline(yintercept = 200) +
  stat_smooth(method = lm) +
  scale_x_log10() + 
  scale_y_log10() + 
  scale_colour_gradient(low = "gray80", high = "black") +
  facet_wrap(~group) + 
  ggtitle("The distributions of joint QC metrics") + 
  theme_bw()

## Filtering using above estimated QC metrics
multi_seurat_obj <- subset(x = multi_seurat_obj, subset = nFeature_RNA >= 200 & nFeature_RNA >= 500 & log10_gene_per_UMI > 0.8 & percent_mt < 5)
multi_seurat_obj_filter <- multi_seurat_obj

## Select genes with a non-zero count appearing in 10 or more cells
count_obj <- GetAssayData(object = multi_seurat_obj_filter, slot = "counts")
count_obj_filter <- count_obj[Matrix::rowSums(count_obj > 0) >= 10, ]
multi_seurat_obj_filter <- CreateSeuratObject(counts = count_obj_filter, meta.data = multi_seurat_obj_filter@meta.data)

## Re-evaluate the most important QC metrics
multi_seurat_obj_filter@meta.data |>
  ggplot(mapping = aes(x = nCount_RNA, y = nFeature_RNA, color = percent_mt)) + 
  geom_point() + 
  geom_vline(xintercept = 500) +
  geom_hline(yintercept = 200) +
  stat_smooth(method = lm) +
  scale_x_log10() + 
  scale_y_log10() + 
  scale_colour_gradient(low = "gray80", high = "black") +
  facet_wrap(~group) + 
  ggtitle("The distributions of joint QC metrics after filtering") + 
  theme_bw()

save(multi_seurat_obj_filter, file = "~/scRNA_analysis/data/derived/multi_seurat_obj_filter.RData")
```

# Assess the sources of variations in the gene expression profiles
## Log normalize the data
```{r}
multi_seurat_obj_lognorm <- NormalizeData(multi_seurat_obj_filter, normalization.method = "LogNormalize", scale.factor = 10000)
# scale.factor: to ensure the uniform UMI counts across all cells, here we multiple each UMI count per cell by a cell-specific factor (initial step of normalization); after this initial step, the log transformation will be applied to each UMI count per gene
```

## See if the cell cycle contributes to the major variations in our dataset
```{r}
load("~/scRNA_analysis/data/cycle_marker.rda")

# Assign the cell cycle score to each cell
multi_seurat_obj_lognorm <- CellCycleScoring(object = multi_seurat_obj_lognorm, 
                                             g2m.features = g2m_genes, 
                                             s.features = s_genes)
# s.features: a vector of features associated with S phase
# g2m.features: a vector of features associated with G2M phase

# Check the cell cycle score and cell cycle phase assigned to each cell                             
View(multi_seurat_obj_lognorm@meta.data)  

# Spot the most variable genes
multi_seurat_obj_lognorm <- FindVariableFeatures(multi_seurat_obj_lognorm, selection.method = "vst", nfeatures = 2000, verbose = FALSE)
		     
# Scale the counts for PCA, such that the average expression level of each gene across cells equals 0, and the variance of expression levels of each gene across cells is 1
multi_seurat_obj_lognorm <- ScaleData(multi_seurat_obj_lognorm)

# Run and visualize PCA colored by cell cycle phase
multi_seurat_obj_lognorm <- RunPCA(multi_seurat_obj_lognorm)
DimPlot(multi_seurat_obj_lognorm, reduction = "pca", group.by = "Phase", split.by = "Phase")
```

## See if the mitochondrial gene expression contributes to the major variations in our dataset
```{r}
percent_mt_q <- quantile(multi_seurat_obj_lognorm@meta.data$percent_mt) 
cut(multi_seurat_obj_lognorm@meta.data$percent_mt_c <- cut(multi_seurat_obj_lognorm@meta.data$percent_mt, breaks = c(-Inf, percent_mt_q[2], percent_mt_q[3], percent_mt_q[4], Inf), labels = c("Low", "Medium", "Medium high", "High"))
DimPlot(multi_seurat_obj_lognorm, reduction = "pca", group.by = "percent_mt_c", split.by = "percent_mt_c")
```

# ! Normalize counts and remove sources of uninteresting variations per condition using sctransform and scaling
```{r}
options(future.globals.maxSize = 4000 * 1024^2)
multi_seurat_obj_split <- SplitObject(multi_seurat_obj_lognorm, split.by = "group")
for (i in 1:length(split_seurat)) {
  multi_seurat_obj_split[[i]] <- SCTransform(multi_seurat_obj_split[[i]], vars.to.regress = c("percent_mt"), vst.flavor = "v2") 
  multi_seurat_obj_split[[i]] <- ScaleData(multi_seurat_obj_split[[i]], vars.to.regress = c("S.Score", "G2M.Score"), features = rownames(multi_seurat_obj_split[[i]]))
  multi_seurat_obj_split[[i]] <- RunPCA(multi_seurat_obj_split[[i]], features = c(s_genes, g2m_genes), verbose = FALSE) # Check if cell cycle impact is regressed out
  DimPlot(multi_seurat_obj_split[[i]], reduction = "pca", group.by = "Phase", split.by = "Phase")
}

multi_seurat_obj_split$wt@assays
multi_seurat_obj_split$kd@assays
multi_seurat_obj_split$over@assays

saveRDS(multi_seurat_obj_split, file = "~/scRNA_analysis/data/derived/multi_seurat_obj_split.rds")
```

# Integrate cells across conditions
## See if there is any condition-specific clustering of the cells
```{r}
multi_seurat_obj_lognorm <- RunUMAP(multi_seurat_obj_lognorm, dims = 1:40, reduction = "pca")
DimPlot(multi_seurat_obj_lognorm)
```

## Perform integration using canonical correlation analysis
```{r}
feature_integrate <- SelectIntegrationFeatures(object.list = multi_seurat_obj_split, nfeatures = 3000) # Choose the most variable features used in integration
multi_seurat_obj_split <- PrepSCTIntegration(object.list = multi_seurat_obj_split, anchor.features = feature_integrate)
anchor_integrate <- FindIntegrationAnchors(object.list = multi_seurat_obj_split, normalization.method = "SCT", anchor.features = feature_integrate)
multi_seurat_obj_integrate <- IntegrateData(anchorset = anchor_integrate, normalization.method = "SCT")
```

## See if integration works well such that each cluster is made up of cells from both conditions
```{r}
multi_seurat_obj_integrate <- RunPCA(object = multi_seurat_obj_integrate)
PCAPlot(multi_seurat_obj_integrate, split.by = "group")  
set.seed(98966)
multi_seurat_obj_integrate <- RunUMAP(multi_seurat_obj_integrate, dims = 1:40, reduction = "pca")
DimPlot(multi_seurat_obj_integrate) 
DimPlot(multi_seurat_obj_integrate, split.by = "group") 

saveRDS(multi_seurat_obj_integrate, "~/scRNA_analysis/data/derived/multi_seurat_obj_integrate.rds")
```

## ! Integrate cells across multiple confounding factors (e.g., experimental conditions donor, tissue/location, species, protocol) 
using `Harmony`
```{r}
BiocManager::install("harmony", version = "3.8")
library(harmony)
multi_seurat_obj_split <- readRDS("~/scRNA_analysis/data/derived/multi_seurat_obj_split.rds")
feature_integrate <- SelectIntegrationFeatures(object.list = multi_seurat_obj_split, nfeatures = 3000)
multi_seurat_obj_merge <- merge(x = multi_seurat_obj_split[[1]], y = multi_seurat_obj_split[2:length(multi_seurat_obj_split)],
		                merge.data = TRUE)
DefaultAssay(multi_seurat_obj_merge) <- "SCT"
VariableFeatures(multi_seurat_obj_merge) <- feature_integrate
multi_seurat_obj_merge <- RunPCA(multi_seurat_obj_merge, assay = "SCT", npcs = 50)
multi_seurat_obj_harmony <- RunHarmony(multi_seurat_obj_merge, group.by.vars = c("group", "batch_id"), reduction = "pca", assay.use = "SCT", reduction.save = "harmony")

# See if Harmony integration is effective in aligning cells across multiple factors
multi_seurat_obj_harmony <- RunUMAP(multi_seurat_obj_harmony, reduction = "harmony", assay = "SCT", dims = 1:40)
DimPlot(multi_seurat_obj_harmony) 
```

# Old fashioned normalization on counts in a single sample
## Normalize the data
```{r}
seurat_obj <- NormalizeData(seurat_obj, normalization.method = "LogNormalize", scale.factor = 10000)
```

## Find variable features
```{r}
seurat_obj <- FindVariableFeatures(seurat_obj, selection.method = "vst", nfeatures = 2000)
top10 <- head(VariableFeatures(seurat_obj), 10)
```

## Scale the data
```{r}
seurat_obj <- ScaleData(seurat_obj, features = rownames(seurat_obj))
```

# Perform linear dimensional reduction
```{r}
seurat_obj <- RunPCA(seurat_obj, features = VariableFeatures(object = seurat_obj))
```

# Cluster the cells
```{r}
seurat_obj <- FindNeighbors(seurat_obj, dims = 1:40)
seurat_obj <- FindClusters(seurat_obj, resolution = seq(0.2, 1.2, 0.2))

# If using the harmony integration before 
seurat_obj_harmony <- FindNeighbors(object = seurat_obj_harmony, reduction = "harmony")
seurat_obj_harmony <- FindClusters(seurat_obj_harmony, resolution = seq(0.2, 1.2, 0.2))
```

# Run non-linear dimensional reduction (t-SNE or UMAP)
```{r}
seurat_obj <- RunUMAP(seurat_obj, dims = 1:10)
```

# Save results
```{r}
saveRDS(seurat_obj, file = "seurat_obj.rds")
```
