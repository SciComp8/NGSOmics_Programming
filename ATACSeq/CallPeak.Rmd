---
title: "ATAC-Seq Data Analysis with Human Data - Call Peaks and Perform Quality Control"
author: "Anni Liu"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: 
  html_document:
    code_folding: show
---

```{r, shorcut, include=FALSE}
## RStudio keyboard shortcut
# Cursor at the beginning of a command line: Ctrl+A
# Cursor at the end of a command line: Ctrl+E
# Clear all the code from your console: Ctrl+L
# Create a pipe operator %>%: Ctrl+Shift+M (Windows) or Cmd+Shift+M (Mac)
# Create an assignment operator <-: Alt+- (Windows) or Option+-(Mac) 
# Knit a document (knitr): Ctrl+Shift+K (Windows) or Cmd+Shift+K (Mac)
# Comment or uncomment current selection: Ctrl+Shift+C (Windows) or Cmd+Shift+C (Mac)
```

# Peak calling
## Install MACS2 using `pip`
```{bash}
 /Users/your_name/Library/r-miniconda-arm64/bin/pip install macs2
 # macs2 and pip are in the same virtual environment
```

## Install MACS2 using `conda`
```{bash}
# Reference: https://docs.conda.io/projects/conda/en/latest/commands/install.html
conda install -p /Users/your_name/Library/r-miniconda-arm64/envs/atac -c "bioconda/label/cf201901" macs2
```

## Install MACS2 using `Herper`
```{r}
# Reference: 
# https://www.bioconductor.org/packages/release/bioc/vignettes/Herper/inst/doc/QuickStart.html
# https://anaconda.org/bioconda/macs2
library(Herper)
tool_dir <- install_CondaTools(tools = "macs3", env = "atac", updateEnv = TRUE)
# pathToMiniConda: NULL Path to miniconda installation
# updateEnv	Update existing package's conda environment if already installed.

# Retured outcomes:
# * Using Miniconda at: /Users/your_name/Library/r-miniconda-arm64
# The environment 'atac' already exists but the tools were not installed because the 'updateEnv' argument was set to FALSE. 
# 
# Conda and Environment Information
# pathToConda : /Users/your_name/Library/r-miniconda-arm64/bin/conda
# environment : atac
# pathToEnvBin : /Users/your_name/Library/r-miniconda-arm64/envs/atac/bin

tool_dir
# $pathToConda
# [1] "/Users/your_name/Library/r-miniconda-arm64/bin/conda"
# 
# $environment
# [1] "atac"
# 
# $pathToEnvBin
# [1] "/Users/your_name/Library/r-miniconda-arm64/envs/atac/bin"
```

## [Outdated] Nucleosome-free peak calling from single-end ATAC-seq data
As we do not know the length of fragments, we typically shift the cutting ends (5') of a read by -100 in 3'->5' direction and then extend reads in 5'->3' direction by 200, which gives us a wider region to increase the chance of calling the peaks in nucleosome-free open regions.
```{r}
# Reference: 
# https://pypi.org/project/MACS2/
# To find enriched cutting sites such as some DNAse-Seq datasets. In this case, all 5' ends of sequenced reads should be extended in both directions to smooth the pileup signals. If the wanted smoothing window is 200bps, then use --nomodel --shift -100 --extsize 200.
# For certain nucleosome-seq data, we need to pile up the centers of nucleosomes using a half-nucleosome size for wavelet analysis (e.g. NPS algorithm). Since the DNA wrapped on nucleosome is about 147bps, this option can be used: --nomodel --shift 37 --extsize 73.

# https://hbctraining.github.io/Intro-to-ChIPseq-flipped/lessons/06_peak_calling_macs.html
with_CondaEnv("atac",
              system2(command = "macs2",
                      args = c("callpeak",
                               "-t", "single_end.bam",
                               "--nomodel",
                               "--shift", "-100",
                               "--extsize", "200",
                               "--format", "BAM",
                               "-g", "hs"),
                      stdout = T))
# -g: mappable genome size which is defined as the genome size which can be sequenced; some precompiled values provided. The default hs -- 2.7e9 is recommended for human genome. Here are all precompiled parameters for effective genome size: hs: 2.7e9 | mm: 1.87e9 | ce: 9e7 | dm: 1.2e8
# stdout: where output to ‘stdout’ should be sent. Possible values are "", to the R console (the default), NULL or FALSE (discard output), TRUE (capture the output in a character vector) or a character string naming a file.
```

## [Outdated] Nucleosome occupied peak calling from single-end ATAC-seq data
As we do not know the length of fragments, we typically shift the cutting ends (5') of a read by 37 in 3'->5' direction and then extend reads in 5'->3' direction by 73.
```{r}
with_CondaEnv("atac",
              system2(command = "macs2", 
                      args = c("callpeak", 
                               "-t", "single_end.bam",
                               "--nomodel",
                               "--shift", "37", # Notice
                               "--extsize", "73", # Notice
                               "--format", "BAM",
                               "-g", "hs"),
                      stdout = T))
```

## Nucleosome-free peak calling from paired-end sequencing - no concerns on the correct specifications of `shift` and `extsize`
```{bash}
# Reference: https://pypi.org/project/MACS2/
# https://biohpc.cornell.edu/lab/doc/Chip-seq_workshop_lecture1.pdf
# -N/--NAME
# The name string of the experiment. MACS will use this string NAME to create output files like NAME_peaks.xls, NAME_negative_peaks.xls, NAME_peaks.bed , NAME_summits.bed, NAME_model.r and so on. So please avoid any confliction between these filenames and your existing files.

# -F/--FORMAT FORMAT
# Format of tag file can be ELAND, BED, ELANDMULTI, ELANDEXPORT, SAM, BAM, BOWTIE, BAMPE, or BEDPE. Default is AUTO which will allow MACS to decide the format automatically. AUTO is also useful when you combine different formats of files. Note that MACS can't detect BAMPE or BEDPE format with AUTO, and you have to implicitly specify the format for BAMPE and BEDPE.
# Nowadays, the most common formats are BED or BAM (including BEDPE and BAMPE). Our recommendation is to convert your data to BED or BAM first.
# Also, MACS2 can detect and read gzipped file. For example, .bed.gz file can be directly used without being uncompressed with --format BED.

# BEDPE or BAMPE
# A special mode will be triggered while the format is specified as BAMPE or BEDPE. In this way, MACS2 will process the BAM or BED files as paired-end data. Instead of building a bimodal distribution of plus and minus strand reads to predict fragment size, MACS2 will use actual insert sizes of pairs of reads to build fragment pileup.
# The BAMPE format is just a BAM format containing paired-end alignment information, such as those from BWA or BOWTIE.

/Users/your_name/Library/r-miniconda-arm64/bin/macs2 callpeak -t Documents/WCM_Project/ATAC_seq/Sorted_ATAC_female_lung_bowtie2_chr1X_free.bam --outdir Documents/WCM_Project/ATAC_seq/Sorted_ATAC_female_lung_bowtie2_chr1X_free_narrowpeak --format BAMPE --name female_lung -g hs
```


```{r suspend}
with_CondaEnv("atac",
              system2(command = "macs2",
                      args = c("callpeak",
                               "-t", "Documents/WCM_Project/ATAC_seq/Sorted_ATAC_female_lung_bowtie2_chr1X_free.bam", # Nucleosome-free open region BMA file
                               "--outdir", "Documents/WCM_Project/ATAC_seq/Sorted_ATAC_female_lung_bowtie2_chr1X_free_narrowpeak/",
                               "--format", "BAM",
                               "--name", "female_lung",
                               "-g", "hs"),
                      stdout = T))
```

# Quality control
```{r}
library(ChIPQC)
library(rtracklayer)
library(DT)
library(dplyr)
library(tidyr)

blkList <- import.bed("./data/ENCFF001TDO.bed.gz")
openRegionPeaks <- "./data/Sorted_ATAC_50K_2_Small_Paired_peaks.narrowPeak/Sorted_ATAC_50K_2_Small_Paired_peaks.narrowPeak"
qcRes <- ChIPQCsample("./data/Sorted_ATAC_50K_2_openRegions.bam",
                      peaks = openRegionPeaks,
                      annotation = "hg19",
                      chromosomes = "chr20",
                      blacklist = blkList,
                      verboseT = FALSE)
```

```{r}
# Calculate reads in peaks and reads in blacklist
myMetrics <- QCmetrics(qcRes)
myMetrics[c("RiBL%", "RiP%")]

# Calculate numbers of duplicated reads 
flgCounts <- flagtagcounts(qcRes)
DupRate <- flgCounts["DuplicateByChIPQC"] / flgCounts["Mapped"] * 100
```

```{r}
# Remove blacklisted peaks
MacsCalls <- granges(qcRes[seqnames(qcRes) %in% "chr20"])
data.frame(Blacklisted = sum(MacsCalls %over% blkList),
           Not_Blacklisted = sum(!MacsCalls %over% blkList))
save(MacsCalls,file = "data/MacsCall_pres2.RData")
```

# Annotation
## Annotate peaks
```{r}
library(ChIPseeker)
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
MacsCalls_Anno <- annotatePeak(MacsCalls, TxDb.Hsapiens.UCSC.hg19.knownGene)
```

## Annotate nucleosome free regions
```{r}
MacsGR_Anno <- as.GRanges(MacsCalls_Anno)

# Subset the peaks on nucleosome free regions to those landing in TSS regions (+/-500)
MacsGR_TSS <- MacsGR_Anno[abs(MacsGR_Anno$distanceToTSS) < 500]
MacsGR_TSS[1, ]
```

# Functional analysis of peaks
```{r}
if (!require("rGREAT", quietly = TRUE)) { BiocManager::install("rGREAT"); library(rGREAT) } else { library(rGREAT) }
great_Job <- submitGreatJob(MacsCalls, species = "hg19")
availableCategories(great_Job)

great_ResultTable <- getEnrichmentTables(great_Job)
names(great_ResultTable)

great_ResultTable[["GO Biological Process"]][1:4, ]
```
